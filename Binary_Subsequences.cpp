// We trace the work of Euclid's algorithm for two coprime integers a,b

// gcd(a,b)=⎧⎩⎨1,gcd(a−b,b),gcd(a,b−a),a=ba>bb>a.
// by writing '1' to a string if the second case and '0' in the third case. For example, for a,b=7,5
// , the string is 1001
// . We denote this string by trace(a,b)
// .

// Let us examine the construction of trace(a,b)
//  in terms of a number of distinct subsequences. By symmetry, we can only consider cnt1(trace(a,b))=
//  the number of distinct subsequences starting with 1
//  (including empty string ∅
// ) in trace(a,b)
// . We have

// cnt1(trace(a,b))={cnt0(trace(a−b,b))+cnt1(trace(a−b,b)),cnt1(trace(a,b−a)),a>bb>a
// Taking cnt1(∅)=cnt0(∅)=1
// , we inductively obtain cnt1(trace(a,b))=a
//  and cnt0(trace(a,b))=b
// . So, the number of distinct subsequences in trace(a,b)
//  is a+b−1
// .

// On the other hand, we can easily see that any binary string can be written via trace(a,b)
//  for some a,b
//  (just perform the algorithm backwards). Therefore, we have a bijection the set of binary strings with exactly n
//  subsequences (including the empty one) and the set of binary strings generated by trace(a,b)
//  for a+b−1=n
// .

// The solution to the problem is easy now if one notices that we can iterate over the strings with exactly n
//  distinct subsequences. Go over a
//  and take b=n−a+1
// , then request (a,b)=1
//  and obtain (a,n+1)=1
// . In other words, the algorithm is the following.

// Increment n
//  by 1 (to eliminate empty substring).
// Iterate over a
//  coprime with n+1
// .
// Take b=n−a+1
//  and relax trace(a,b)
// .

#include <bits/stdc++.h>
using namespace std;
string trace(int a, int b)
{
    if (a == b)
        return "";
    else if (a > b)
        return '1' + trace(a - b, b);
    else
        return '0' + trace(a, b - a);
}
int trace_len(int a, int b)
{
    if (a == b)
        return 0;
    else if (a > b)
        return 1 + trace_len(a - b, b);
    else
        return 1 + trace_len(a, b - a);
}
int main()
{
    int n;
    cin >> n;
    int b, mn = ++n;
    for (int a = 1; a <= n + 1; a++)
    {
        if (__gcd(a, n + 1) != 1)
            continue;
        int len = trace_len(a, n - a + 1);
        if (len < mn)
            mn = len, b = n - a + 1;
    }
    cout << trace(n - b + 1, b) << "\n";
}